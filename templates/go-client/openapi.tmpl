package {{ index .GetMetadata "package" }}

import (
    "context"
	"errors"
	"fmt"
	"net/http"
	"net/url"
	"strings"

 	"github.com/go-playground/validator/v10"
)

// ClientService is the interface for Client methods
type ClientService interface {
    {{- range $pathName, $path := .Paths }}
    {{- range $name, $operation := $path.Operations }}
    {{ $operation.GetName | SanitiseName }}(context.Context, *{{ $operation.GetName | SanitiseName }}Parameters, *{{ $operation.RequestBody.GetName | SanitiseName }}) (*http.Response, error)
    {{- end }}
    {{- end }}
}

var _ ClientService = &Client{}

// AuthFunc needs to be passed in as a closure at client generation and allows for authentication to be applied to any
// request being made. It should contain any logic and data needed to apply and maintain authentication with a server.
type AuthFunc func(*http.Request) error

// Config allows you to specify the Host, Protocol, Content Type and optionally a Port when initialising this client.
// It should only be used once, when calling NewHTTPClient.
type Config struct {
	Host string `validate:"required"`
	Protocol string `validate:"required"`
	ContentType string `validate:"required"`
	Port string
}

type Client struct {
    *http.Client

    cfg *Config
	auth AuthFunc
}

func (c *Client) createUrl(pathPattern string, vals url.Values) url.URL {
	u := url.URL{
		Scheme:   c.cfg.Protocol,
		Host:     c.cfg.Host,
		Path:     pathPattern,
		RawQuery: vals.Encode(),
	}
	if c.Port != "" {
	    u.Host += ":"
	    u.Host += c.Port
	}
	return u
}

// NewHTTPClient allows you to specify the configuration of your client. This function allows you to specify optional
// auth steps that will be executed before a request is made, such as the attaching of an Authorization header to the
// request, as well as the http.Client you intend to use to make the calls. See the config struct for an idea of what it
// allows you to configure.
func NewHTTPClient(cfg *Config, client *http.Client, af AuthFunc) (*Client, error) {
    if cfg == nil {
          return nil, errors.New("cannot start client without config")
    }
    validate := validator.New()
    if err := validate.Struct(cfg); err != nil {
        return nil, err
    }
	if strings.Contains(cfg.Host, "://") {
		cfg.Host = strings.Split(cfg.Host, "://")[1]
	}
    c := &Client{
        cfg: cfg,
        auth: af,
    }
    if client == nil {
        c.Client = http.DefaultClient
    } else {
        c.Client = client
    }
    return c, nil
}
